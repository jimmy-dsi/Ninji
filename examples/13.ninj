// Threading example
module main

import threads as .

thread_data_1 := shared object { 
	counter: 0,
	flag:    false,
	write:   ""
}
// `shared` creates an instance of `shared(subtype)` type.
// It contains all the same members and methods as the source type, but also has locks for each member.
// When a member is accessed, it is locked with its respective member lock first (additional code generated by compiler)
// When a method is invoked on any of the members, the member is locked as well.
//	- Note: This does not apply to its sub-members, unless they are `shared` types as well.
//	- Note: There is also no overarching lock for the entire object, only its resources
// If a method is invoked on the shared object as a whole, the whole object is locked by the overarching lock.

global_data := "dsfhjdh"
global_lock := mutex {}

proc main() {
	print("Before threads")
	t1 := spawn thread_1(19)
	t2 := spawn thread_2(42, "things")
	
	print("During threads")
	
	t1.wait()
	t2.wait()
	
	print($"After threads: {result as *int}")
}

proc thread_1(a int) {
	for i in range(a) {
		print(i)
	}
}

proc thread_2(a int, b *string) int {
	while steps := 0  i := a ... i > 0 ... i /= 2  steps += 1 {
		print($"{i} {b}!")
	}
	
	if a >= 100 {
		yield // Let other threads take control (temporarily)
	} else if a >= 1000 {
		sleep(1000) // Let other threads take control for 1,000 ms
	}
	
	return steps // Warning: Return value cannot be utilized by thread caller
}

proc thread_3(c char) {
	lock global_lock {
		global_data += c
	}
}

/* Output:

Before threads
0
1
2
42 things!
21 things!
3
4
5
During threads
10 things!
6
7
5 things!
2 things!
8
9
10
1 things!
11
12
13
14
15
16
17
18
After threads: 6

*/